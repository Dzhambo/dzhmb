# -*- coding: utf-8 -*-
"""Бинарное дерево поиска.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UP7U6smRR99wCsJ5oS9G8x2Nc0k6fJOQ
"""

class Node():

  def __init__(self,data):
    self.data = data
    self.left = None
    self.right = None

  def insert(self, data):

    if self.data:
      if data>self.data:
        if self.right:
          self.right.insert(data)
        else:
          self.right = Node(data)
      elif data<self.data:
        if self.left:
          self.left.insert(data)
        else:
          self.left = Node(data)
    else:
      self.data = data
  
  def print_tree(self):

    if self.left:
      self.left.print_tree()
    print(self.data)
    if self.right:
      self.right.print_tree()
  
  def get_leaves(self, root):
    result = []
    if root:
        result = self.get_leaves(root.left)
        result = result+self.get_leaves(root.right)
        if root.left is None and root.right is None:
            result.append(root.data)
    return result
  
  def get_fullnode(self,root):
    result = []
    if root:
      result = self.get_fullnode(root.left)
      result += self.get_fullnode(root.right)
      if root.left is not None and root.right is not None:
        result.append(root.data)
    return result

  def get_vetka(self,root):
    result = []
    if root:
      result = self.get_vetka(root.left)
      result+= self.get_vetka(root.right)
      if (root.left is None and root.right is not None) or (root.left is not None and root.right is None):
        result.append(root.data)
    return result

  def get_max_nodes(self,root):
    result = []
    if root:
      if root.right:
        result = self.get_max_nodes(root.right)
      if root.left:
        result+= self.get_max_nodes(root.left)
      result.append(root.data)
    result.sort()
    return result


def get_node(node,data,depth=0):
  depth+=1
  if data is None:
    return None
  if data==node.data:
    return node, depth
  elif data<node.data:
    return get_node(node.left,data, depth)
  else:
    return get_node(node.right, data, depth)

def is_balanced(node):
  if abs(max_depth(node.left)-max_depth(node.right))<=1:
    return True
  return False


def max_depth(node):

  if node is None:
    return 0
    
  left_depth = max_depth(node.left)
  right_depth = max_depth(node.right)

  return max(left_depth,right_depth)+1

